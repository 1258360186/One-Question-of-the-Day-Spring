# 每日一题·春

## 第十五天(AcWing)

### 592. 雨

#### 题目

海里有一个小岛。

岛可以描述为一个具有 $R$ 行 $C$ 列的矩阵，其中包含的数字 $H[i][j]$ 表示每个单元格的高度。

以下是一个 $3×3$ 岛屿的示例：

```
3 5 5
5 4 5
5 5 5
```

有时，大雨会在这个岛上的每个单元格上均匀地降落。

你可以假设降水量可以是无限大。

在这样的大雨之后，岛上的一些区域（由沿着边缘连接的一个或多个单元格形成）可能会存在积水。

一片区域可以存在积水的前提是与该区域内单元格沿着边缘连接的区域外的单元格的高度均高于区域内单元格。（周围的海洋被视为高度为 $0$ 的无限单元格。）

否则，水将始终流入其他区域并最终出海。

你可以假设海的高度永远不会改变。

在大雨过后，我们将使用 $W[i][j]$ 来表示岛屿上每个单元格的高度。

以下是对大雨过后的示例岛屿的高度的分析。

最中央的初始高度为 $4$ 的单元格被初始高度为 $5$ 的单元格包围着，因此在该单元格将产生积水，在积水高度到达 $5$ 以后，没有更多区域被高度更高的单元格包围，因此将不再继续积水。

请注意，水不会直接在两个共享顶点的单元格之间流动;水必须沿着共同的边缘流动。（所以中央单元格的积水不会从左上角处流走）

以下是雨后示例岛屿的高度：

```
3 5 5
5 5 5
5 5 5
```

给定岛的高度矩阵，你能计算出大雨后的每个单元格的增加高度（$W[i][j]$-$H[i][j]$）的总和吗？

#### 输入格式

第一行包含整数 $T$，表示共有 $T$ 组测试数据。

每组数据第一行包含两个整数 $R$ 和 $C$。

接下来 $R$ 行每行包含 $C$ 个整数 $H[i][j]$，表示矩阵内单元格的高度。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 $x$ 是组别编号（从 $1$ 开始），$y$ 是增加高度的总和。

#### 数据范围

$1≤T≤100$,
$1≤H[i][j]≤1000$,​
$1≤R,C≤50$

#### 输入样例

```
3
3 3
3 5 5
5 4 5
5 5 5
4 4
5 5 5 1
5 1 1 5
5 1 5 5
5 2 5 8
4 3
2 2 2
2 1 2
2 1 2
2 1 2
```

#### 输出样例

```
Case #1: 1
Case #2: 3
Case #3: 0
```

#### 样例解释

```
样例#1已经在题目中说明。

在样例#2中，雨后岛屿看起来像这样：

5 5 5 1
5 2 2 5
5 2 5 5
5 2 5 8

样例#3在雨后保持不变。
```

#### AC代码

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>

using namespace std;

int h[55][55];
bool st[55][55];
int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

struct Node{
    int x,y,h;
    
    //如果是<，从小到大,如果是>，从大到小
    //大顶堆 重载小于号 less() priority_queue默认
    //小顶堆 重载大于号 greater()
    //使用默认priority_queue实现小顶堆方式
    //bool operator< (const Node& t) const {
    //    return h > t.h;
    //}
    bool operator>(const Node& t) const{
        return h>t.h;
    }
    
};

int main()
{
    int T,R,C;
    cin >> T ;
    for (int num = 1; num <= T; num++){
        cin >> R >> C;
        int res=0;
        memset(st,0,sizeof st);
        priority_queue<Node,vector<Node>,greater<Node>>q;//这样就是小顶堆
        //读入
        for(int i=0;i<R;i++)
            for(int j=0;j<C;j++)
                cin >> h[i][j];
        //边角四个点标记为已经遍历
        st[0][0] = st[0][C - 1] = st[R - 1][0] = st[R - 1][C - 1] = true;
        //外圈中横着的点（不包括四个角）
        for(int i=1;i<C-1;i++){
            st[0][i]=st[R-1][i]=true;
            q.push({0,i,h[0][i]});
            q.push({R-1,i,h[R-1][i]});
        }
        //外圈中竖着的点（不包括四个角）
        for(int i=1;i<R-1;i++){
            st[i][0]=st[i][C-1]=true;
            q.push({i,0,h[i][0]});
            q.push({i,C-1,h[i][C-1]});
        }
        while(q.size()){
            auto t=q.top();
            q.pop();
            for (int i = 0; i < 4; i++){
                int tx=t.x+dx[i],ty=t.y+dy[i];
                
                //判断是否超范围或者被遍历过了
                if (tx < R && tx >= 0 && ty < C && ty >= 0 && !st[tx][ty]){
                    st[tx][ty] = true;//标记
                    
                    //res加上该点的木桶高度和它高度的差，
                    //如果大于0就是积水量
                    res += max(0, t.h - h[tx][ty]);
                    
                    //注意，push的是上下左右点的最大高度，
                    //如果木桶高度小于它高度，仍然要它本身的高度，
                    //因为它是新边界，而边界高度就是木桶高度和原本高度的最大值
                    q.push({tx, ty, max(t.h, h[tx][ty])});
                }
            }
        }
        printf("Case #%d: %d\n", num , res);
    }
}
```

#### 解题思路

> **木桶效应缩圈**

>

