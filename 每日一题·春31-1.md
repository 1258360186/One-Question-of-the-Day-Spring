# 每日一题·春

## 第三十一天(AcWing)

### 12. 背包问题求具体方案

#### 题目

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。

第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出 **字典序最小的方案**。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。

#### 输入格式

第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。

接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

#### 输出格式

输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

物品编号范围是 $1…N$。

#### 数据范围

$0<N,V≤1000$
$0<v_i,w_i≤1000$

#### 输入样例

```
4 5
1 2
2 4
3 4
4 6
```

#### 输出样例

```
1 4
```

#### 样例解释

```

```

#### AC代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int f[1010][1010];
int v[1010],w[1010];

int main(){
    int N,V;
    cin >> N >> V;
    for(int i=1;i<=N;i++) cin >> v[i] >> w[i];
    for(int i = N;i;i--)
        for(int j=0;j<=V;j++){
            f[i][j] = f[i + 1][j];
            if (j >= v[i])
                f[i][j] = max(f[i+1][j],f[i+1][j-v[i]]+w[i]);
        }
        
    int i = 1, j = V;
    while (i <= N)
    {
        if (j >= v[i] && f[i + 1][j - v[i]] + w[i] >= f[i + 1][j])
        {
            printf("%d ", i);
            j -= v[i];
            i ++ ;
        }
        else i ++ ;
    }
    return 0;
}
```

#### 解题思路

> **二维前缀和**

>题目要求输出字典序最小的解，假设存在一个包含第1个物品的最优解，为了确保字典序最小那么我们必然要选第一个。那么问题就转化成从2～N这些物品中找到最优解。之前的f(i,j)f(i,j)记录的都是前ii个物品总容量为jj的最优解，那么我们现在将f(i,j)f(i,j)定义为从第ii个元素到最后一个元素总容量为jj的最优解。接下来考虑状态转移：
>
>f(i,j)=max(f(i+1,j),f(i+1,j−v[i])+w[i])f(i,j)=max(f(i+1,j),f(i+1,j−v[i])+w[i])
>两种情况，第一种是不选第ii个物品，那么最优解等同于从第i+1i+1个物品到最后一个元素总容量为jj的最优解；第二种是选了第ii个物品，那么最优解等于当前物品的价值w[i]w[i]加上从第i+1i+1个物品到最后一个元素总容量为j−v[i]j−v[i]的最优解。
>
>计算完状态表示后，考虑如何的到最小字典序的解。首先f(1,m)f(1,m)肯定是最大价值，那么我们便开始考虑能否选取第1个物品呢。
>
>如果f(1,m)=f(2,m−v[1])+w[1]f(1,m)=f(2,m−v[1])+w[1]，说明选取了第1个物品可以得到最优解。
>
>如果f(1,m)=f(2,m)f(1,m)=f(2,m)，说明不选取第一个物品才能得到最优解。
>
>来源：[AcWing](https://www.acwing.com/solution/content/2687/)

