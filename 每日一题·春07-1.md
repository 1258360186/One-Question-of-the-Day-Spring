# 每日一题·春

## 第七天(AcWing)

### 131. 直方图中最大的矩形

#### 题目

直方图是由在公共基线处对齐的一系列矩形组成的多边形。

矩形具有相等的宽度，但可以具有不同的高度。

例如，图例左侧显示了由高度为 $2,1,4,5,1,3,3$ 的矩形组成的直方图，矩形的宽度都为 $1$：

![2559_1.jpg](https://www.acwing.com/media/article/image/2019/01/14/19_eac6c46017-2559_1.jpg)

通常，直方图用于表示离散分布，例如，文本中字符的频率。

现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。

图例右图显示了所描绘直方图的最大对齐矩形。

#### 输入格式

输入包含几个测试用例。

每个测试用例占据一行，用以描述一个直方图，并以整数 nn 开始，表示组成直方图的矩形数目。

然后跟随 $n$ 个整数 $h_1，…，h_n$。

这些数字以从左到右的顺序表示直方图的各个矩形的高度。

每个矩形的宽度为 $1$。

同行数字用空格隔开。

当输入用例为 $n=0$ 时，结束输入，且该用例不用考虑。

#### 输出格式

对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。

每个数据占一行。

请注意，此矩形必须在公共基线处对齐。

#### 数据范围

$1≤n≤100000$,
$0≤h_i≤1000000000$

#### 输入样例

```
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0
```

#### 输出样例

```
8
4000
```

#### 样例解释



#### AC代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;
int n;
int h[100010],l[100010],r[100010],stk[100010];//l[i], r[i]表示第i个矩形的高度可向两侧扩展的左右边界
int tt=-1;

int main()
{
    while(cin >> n,n){
        for(int i=1;i<=n;i++) cin >> h[i];
        h[0]=h[n+1]=-1;//为使每个矩形的两侧都有矮于它的矩形
        tt=-1;//初始化栈为空
        stk[++tt]=0;//初始化栈顶为空
        for(int i=1;i<=n;i++){//对左边进行单调栈操作
            while(h[stk[tt]]>=h[i]) tt--;
            l[i]=stk[tt];//记录左边可到达端点
            stk[++tt]=i;
        }
        tt=-1;//初始化栈为空
        stk[++tt]=n+1;//初始化栈顶为空
        for(int i=n;i;i--){//对右边进行单调栈操作
            while(h[stk[tt]]>=h[i]) tt--;
            r[i]=stk[tt];//记录右边可到达端点
            stk[++tt]=i;
        }
        LL res=0;
        for(int i=1;i<=n;i++){
            res=max(res,(LL)h[i]*(r[i]-l[i]-1));//计算最大面积
        }
        cout << res << endl;
    }
    return 0;
}
```

#### 解题思路

> **单调栈**

> 